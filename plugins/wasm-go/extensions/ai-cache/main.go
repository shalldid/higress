// File generated by hgctl. Modify as required.
// See: https://higress.io/zh-cn/docs/user/wasm-go#2-%E7%BC%96%E5%86%99-maingo-%E6%96%87%E4%BB%B6

package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strconv"
	"strings"

	"github.com/alibaba/higress/plugins/wasm-go/pkg/wrapper"
	"github.com/higress-group/proxy-wasm-go-sdk/proxywasm"
	"github.com/higress-group/proxy-wasm-go-sdk/proxywasm/types"
	"github.com/tidwall/gjson"
)

var QueueCache = Queue{
	MaxSize:      2,
	ContentArray: [2]string{},
}

const (
	CacheKeyContextKey       = "cacheKey"
	CacheContentContextKey   = "cacheContent"
	PartialMessageContextKey = "partialMessage"
	ToolCallsContextKey      = "toolCalls"
	StreamContextKey         = "stream"
	DefaultCacheKeyPrefix    = ""
	QueryEmbeddingKey        = "query-embedding"
)

func main() {
	wrapper.SetCtx(
		"ai-cache",
		wrapper.ParseConfigBy(parseConfig),
		wrapper.ProcessRequestHeadersBy(onHttpRequestHeaders),
		wrapper.ProcessRequestBodyBy(onHttpRequestBody),
		wrapper.ProcessResponseHeadersBy(onHttpResponseHeaders),
		wrapper.ProcessStreamingResponseBodyBy(onHttpResponseBody),
	)
}

// @Name ai-cache
// @Category protocol
// @Phase AUTHN
// @Priority 10
// @Title zh-CN AI Cache
// @Description zh-CN 大模型结果缓存
// @IconUrl
// @Version 0.1.0
//
// @Contact.name johnlanni
// @Contact.url
// @Contact.email
//
// @Example
// redis:
//   serviceName: my-redis.dns
//   timeout: 2000
// cacheKeyFrom:
//   requestBody: "messages.@reverse.0.content"
// cacheValueFrom:
//   responseBody: "choices.0.message.content"
// cacheStreamValueFrom:
//   responseBody: "choices.0.delta.content"
// returnResponseTemplate: |
//   {"id":"from-cache","choices":[{"index":0,"message":{"role":"assistant","content":"%s"},"finish_reason":"stop"}],"model":"gpt-4o","object":"chat.completion","usage":{"prompt_tokens":0,"completion_tokens":0,"total_tokens":0}}
// returnStreamResponseTemplate: |
//   data:{"id":"from-cache","choices":[{"index":0,"delta":{"role":"assistant","content":"%s"},"finish_reason":"stop"}],"model":"gpt-4o","object":"chat.completion","usage":{"prompt_tokens":0,"completion_tokens":0,"total_tokens":0}}
//
//   data:[DONE]
//
// @End

type RedisInfo struct {
	// @Title zh-CN redis 服务名称
	// @Description zh-CN 带服务类型的完整 FQDN 名称，例如 my-redis.dns、redis.my-ns.svc.cluster.local
	ServiceName string `required:"true" yaml:"serviceName" json:"serviceName"`
	// @Title zh-CN redis 服务端口
	// @Description zh-CN 默认值为6379
	ServicePort int `required:"false" yaml:"servicePort" json:"servicePort"`
	// @Title zh-CN 用户名
	// @Description zh-CN 登陆 redis 的用户名，非必填
	Username string `required:"false" yaml:"username" json:"username"`
	// @Title zh-CN 密码
	// @Description zh-CN 登陆 redis 的密码，非必填，可以只填密码
	Password string `required:"false" yaml:"password" json:"password"`
	// @Title zh-CN 请求超时
	// @Description zh-CN 请求 redis 的超时时间，单位为毫秒。默认值是1000，即1秒
	Timeout int `required:"false" yaml:"timeout" json:"timeout"`
}

type DashScopeInfo struct {
	DashScopeServiceName string             `require:"true" yaml:"DashScopeServiceName" json:"DashScopeServiceName"`
	DashScopeDomain      string             `require:"true" yaml:"DashScopeDomain" json:"DashScopeDomain"`
	DashScopeKey         string             `require:"true" yaml:"DashScopeKey" json:"DashScopeKey"`
	DashScopeClient      wrapper.HttpClient `yaml:"-" json:"-"`
}

type DashVectorInfo struct {
	DashVectorServiceName              string             `require:"true" yaml:"DashVectorServiceName" json:"DashVectorServiceName"`
	DashVectorDomain                   string             `require:"true" yaml:"DashVectorDomain" json:"DashVectorDomain"`
	DashVectorKey                      string             `require:"true" yaml:"DashVectorKey" json:"DashVectorKey"`
	DashVectorCollection               string             `require:"true" yaml:"DashVectorCollection" json:"DashVectorCollection"`
	DashVectorNearestScoreThreshold    float64            `require:"true" yaml:"DashVectorNearestScoreThreshold" json:"DashVectorNearestScoreThreshold"`
	DashVectorNearestScoreMinThreshold float64            `require:"true" yaml:"DashVectorNearestScoreMinThreshold" json:"DashVectorNearestScoreMinThreshold"`
	DashVectorIgnorePrefix             string             `require:"true" yaml:"DashVectorIgnorePrefix" json:"DashVectorIgnorePrefix"`
	DashVectorMinLengthThreshold       uint8              `require:"true" yaml:"DashVectorMinLengthThreshold" json:"DashVectorMinLengthThreshold"`
	DashVectorProperNoun               []string           `require:"true" yaml:"DashVectorProperNoun" json:"DashVectorProperNoun"`
	DashVectorChEnEnhance              bool               `require:"true" yaml:"DashVectorChEnEnhance" json:"DashVectorChEnEnhance"`
	DashVectorClient                   wrapper.HttpClient `yaml:"-" json:"-"`
}

type KVExtractor struct {
	// @Title zh-CN 从请求 Body 中基于 [GJSON PATH](https://github.com/tidwall/gjson/blob/master/SYNTAX.md) 语法提取字符串
	RequestBody string `required:"false" yaml:"requestBody" json:"requestBody"`
	// @Title zh-CN 从响应 Body 中基于 [GJSON PATH](https://github.com/tidwall/gjson/blob/master/SYNTAX.md) 语法提取字符串
	ResponseBody string `required:"false" yaml:"responseBody" json:"responseBody"`
}

type PluginConfig struct {
	// @Title zh-CN 向量数据库 地址信息
	// @Description zh-CN 用于存储向量结果的 向量数据库 地址
	DashVectorInfo DashVectorInfo `required:"true" yaml:"dashVectorInfo" json:"dashVectorInfo"`
	// @Title zh-CN 通义千问 地址信息
	// @Description zh-CN 用于文本Embedding，获取文本向量数据地址
	DashScopeInfo DashScopeInfo `required:"true" yaml:"dashScopeInfo" json:"dashScopeInfo"`
	// @Title zh-CN Redis 地址信息
	// @Description zh-CN 用于存储缓存结果的 Redis 地址
	RedisInfo RedisInfo `required:"true" yaml:"redis" json:"redis"`
	// @Title zh-CN 缓存 key 的来源
	// @Description zh-CN 往 redis 里存时，使用的 key 的提取方式
	CacheKeyFrom KVExtractor `required:"true" yaml:"cacheKeyFrom" json:"cacheKeyFrom"`
	// @Title zh-CN 缓存 value 的来源
	// @Description zh-CN 往 redis 里存时，使用的 value 的提取方式
	CacheValueFrom KVExtractor `required:"true" yaml:"cacheValueFrom" json:"cacheValueFrom"`
	// @Title zh-CN 流式响应下，缓存 value 的来源
	// @Description zh-CN 往 redis 里存时，使用的 value 的提取方式
	CacheStreamValueFrom KVExtractor `required:"true" yaml:"cacheStreamValueFrom" json:"cacheStreamValueFrom"`
	// @Title zh-CN 返回 HTTP 响应的模版
	// @Description zh-CN 用 %s 标记需要被 cache value 替换的部分
	ReturnResponseTemplate string `required:"true" yaml:"returnResponseTemplate" json:"returnResponseTemplate"`
	// @Title zh-CN 返回流式 HTTP 响应的模版
	// @Description zh-CN 用 %s 标记需要被 cache value 替换的部分
	ReturnStreamResponseTemplate string `required:"true" yaml:"returnStreamResponseTemplate" json:"returnStreamResponseTemplate"`
	// @Title zh-CN 缓存的过期时间
	// @Description zh-CN 单位是秒，默认值为0，即永不过期
	CacheTTL      int             `required:"false" yaml:"cacheTTL" json:"cacheTTL"`
	ProperNounSet ProperNounStack `yaml:"-" json:"-"`
	// @Title zh-CN Redis缓存Key的前缀
	// @Description zh-CN 默认值是"higress-ai-cache:"
	CacheKeyPrefix string              `required:"false" yaml:"cacheKeyPrefix" json:"cacheKeyPrefix"`
	RedisClient    wrapper.RedisClient `yaml:"-" json:"-"`
}

type DashScopeEmbeddingRequest struct {
	Model      string     `json:"Model"`
	Input      string     `json:"input"`
	Parameters Parameters `json:"parameters"`
}

type DashScopeEmbeddingResponse struct {
	RequestId string                           `json:"request_id"`
	Usage     Usage                            `json:"usage"`
	Output    DashScopeEmbeddingResponseOutput `json:"output"`
}

type Parameters struct {
	TextType string `json:"text_type"`
}

type Usage struct {
	TotalTokens int `json:"total_tokens"`
}

type DashScopeEmbeddingResponseOutput struct {
	Embeddings []EmbeddingData `json:"embeddings"`
}

type EmbeddingData struct {
	Embedding []float64 `json:"embedding"`
	TextIndex int       `json:"text_index"`
}

type DashVectorInsertRequest struct {
	Documents []Documents `json:"docs"`
}

type DashVectorSearchRequest struct {
	Vector        []float64 `json:"vector"`
	TopK          int       `json:"topk"`
	IncludeVector bool      `json:"include_vector"`
}

type DashVectorSearchResponse struct {
	Status    int                              `json:"code"`
	RequestId string                           `json:"request_id"`
	Message   string                           `json:"message"`
	Output    []DashVectorSearchResponseOutput `json:"output"`
}

type Documents struct {
	Vector []float64 `json:"vector"`
	Fields Fields    `json:"fields"`
}

type Fields struct {
	OriginQuestion string `json:"originQuestion"`
	Content        string `json:"content"`
}

type DashVectorSearchResponseOutput struct {
	ID     string    `json:"id"`
	Score  float64   `json:"score"`
	Fields Fields    `json:"fields"`
	Vector []float64 `json:"vector"`
}

type Queue struct {
	Size         int
	MaxSize      int
	ContentArray [2]string
}

type ProperNounStack struct {
	Row   uint8
	Coupe []ProperNounStackEle
}

type ProperNounStackEle struct {
	Ele []string
}

func parseConfig(json gjson.Result, c *PluginConfig, log wrapper.Log) error {

	log.Infof("config:%s", json.Raw)

	// init DashVector http client
	log.Infof("Start to init DashVector's http client.")
	c.DashVectorInfo.DashVectorKey = json.Get("DashVector.DashVectorKey").String()
	log.Infof("DashVectorKey:%s", c.DashVectorInfo.DashVectorKey)
	if c.DashVectorInfo.DashVectorKey == "" {
		return errors.New("DashVector.DashVectorKey must not be empty")
	}
	c.DashVectorInfo.DashVectorServiceName = json.Get("DashVector.DashVectorServiceName").String()
	log.Infof("DashVectorServiceName:%s", c.DashVectorInfo.DashVectorServiceName)
	if c.DashVectorInfo.DashVectorServiceName == "" {
		return errors.New("DashVector.DashVectorServiceName must not be empty")
	}
	c.DashVectorInfo.DashVectorDomain = json.Get("DashVector.DashVectorDomain").String()
	log.Infof("DashVectorDomain:%s", c.DashVectorInfo.DashVectorDomain)
	if c.DashVectorInfo.DashVectorDomain == "" {
		return errors.New("DashVector.DashVectorDomain must not be empty")
	}
	c.DashVectorInfo.DashVectorCollection = json.Get("DashVector.DashVectorCollection").String()
	log.Infof("DashVectorCollection:%s", c.DashVectorInfo.DashVectorCollection)
	if c.DashVectorInfo.DashVectorCollection == "" {
		return errors.New("DashVector.DashVectorCollection must not be empty")
	}

	c.DashVectorInfo.DashVectorNearestScoreThreshold = json.Get("DashVector.DashVectorNearestScoreThreshold").Float() / 100000.0
	log.Infof("DashVectorNearestScoreThreshold:%f", c.DashVectorInfo.DashVectorNearestScoreThreshold)
	if c.DashVectorInfo.DashVectorNearestScoreThreshold <= 0 {
		return errors.New("DashVector.DashVectorNearestScoreThreshold must not less than or equal to zero")
	}

	c.DashVectorInfo.DashVectorNearestScoreMinThreshold = json.Get("DashVector.DashVectorNearestScoreMinThreshold").Float() / 100000.0
	log.Infof("DashVectorNearestScoreMinThreshold:%f", c.DashVectorInfo.DashVectorNearestScoreMinThreshold)
	if c.DashVectorInfo.DashVectorNearestScoreMinThreshold < 0 {
		return errors.New("DashVector.DashVectorNearestScoreMinThreshold must not less than zero")
	}

	c.DashVectorInfo.DashVectorIgnorePrefix = json.Get("DashVector.DashVectorIgnorePrefix").String()
	log.Infof("DashVectorIgnorePrefix:%s", c.DashVectorInfo.DashVectorIgnorePrefix)

	c.DashVectorInfo.DashVectorMinLengthThreshold = uint8(json.Get("DashVector.DashVectorMinLengthThreshold").Uint())
	log.Infof("DashVectorMinLengthThreshold:%d", c.DashVectorInfo.DashVectorMinLengthThreshold)
	if c.DashVectorInfo.DashVectorMinLengthThreshold < 0 {
		return errors.New("DashVector.DashVectorMinLengthThreshold must not less than zero")
	}

	c.DashVectorInfo.DashVectorChEnEnhance = json.Get("DashVector.DashVectorChEnEnhance").Bool()
	log.Infof("DashVectorChEnEnhance:%t", c.DashVectorInfo.DashVectorChEnEnhance)

	ProperNounArraysStr := json.Get("DashVector.DashVectorProperNoun").Array()
	c.ProperNounSet = ProperNounStack{
		Row:   0,
		Coupe: make([]ProperNounStackEle, len(ProperNounArraysStr)),
	}

	for _, ArrayStr := range ProperNounArraysStr {
		ProperNounList := strings.Split(ArrayStr.String(), ",")
		ProperNounSetEle := ProperNounStackEle{
			Ele: make([]string, len(ProperNounList)),
		}
		for i, ProperNounVar := range ProperNounList {
			ProperNounSetEle.Ele[i] = ProperNounVar
		}
		c.ProperNounSet.Coupe[c.ProperNounSet.Row] = ProperNounSetEle
		c.ProperNounSet.Row++
	}
	log.Infof("DashVectorProperNoun:%s", c.ProperNounSet.print())

	c.DashVectorInfo.DashVectorClient = wrapper.NewClusterClient(wrapper.DnsCluster{
		ServiceName: c.DashVectorInfo.DashVectorServiceName,
		Port:        443,
		Domain:      c.DashVectorInfo.DashVectorDomain,
	})

	// init DashScope http client
	log.Infof("Start to init DashScope's http client.")
	c.DashScopeInfo.DashScopeServiceName = json.Get("DashScope.DashScopeServiceName").String()
	log.Infof("DashScopeServiceName:%s", c.DashScopeInfo.DashScopeServiceName)
	if c.DashScopeInfo.DashScopeServiceName == "" {
		return errors.New("DashScope.DashScopeServiceName must not by empty")
	}
	c.DashScopeInfo.DashScopeDomain = json.Get("DashScope.DashScopeDomain").String()
	log.Infof("DashScopeDomain:%s", c.DashScopeInfo.DashScopeDomain)
	if c.DashScopeInfo.DashScopeDomain == "" {
		return errors.New("DashScope.DashScopeDomain must not by empty")
	}
	c.DashScopeInfo.DashScopeKey = json.Get("DashScope.DashScopeKey").String()
	log.Infof("DashScopeKey:%s", c.DashScopeInfo.DashScopeKey)
	if c.DashScopeInfo.DashScopeKey == "" {
		return errors.New("DashScope.DashScopeKey must not by empty")
	}
	c.DashScopeInfo.DashScopeClient = wrapper.NewClusterClient(wrapper.FQDNCluster{
		FQDN: c.DashScopeInfo.DashScopeServiceName,
		Port: 35335,
	})

	// init redis client
	log.Infof("Start to init redis client.")
	c.RedisInfo.ServiceName = json.Get("redis.serviceName").String()
	if c.RedisInfo.ServiceName == "" {
		return errors.New("redis service name must not be empty")
	}
	c.RedisInfo.ServicePort = int(json.Get("redis.servicePort").Int())
	if c.RedisInfo.ServicePort == 0 {
		if strings.HasSuffix(c.RedisInfo.ServiceName, ".static") {
			// use default logic port which is 80 for static service
			c.RedisInfo.ServicePort = 80
		} else {
			c.RedisInfo.ServicePort = 6379
		}
	}
	c.RedisInfo.Username = json.Get("redis.username").String()
	c.RedisInfo.Password = json.Get("redis.password").String()
	c.RedisInfo.Timeout = int(json.Get("redis.timeout").Int())
	if c.RedisInfo.Timeout == 0 {
		c.RedisInfo.Timeout = 1000
	}
	c.CacheKeyFrom.RequestBody = json.Get("cacheKeyFrom.requestBody").String()
	if c.CacheKeyFrom.RequestBody == "" {
		c.CacheKeyFrom.RequestBody = "messages.@reverse.0.content"
	}
	c.CacheValueFrom.ResponseBody = json.Get("cacheValueFrom.responseBody").String()
	if c.CacheValueFrom.ResponseBody == "" {
		c.CacheValueFrom.ResponseBody = "choices.0.message.content"
	}
	c.CacheStreamValueFrom.ResponseBody = json.Get("cacheStreamValueFrom.responseBody").String()
	if c.CacheStreamValueFrom.ResponseBody == "" {
		c.CacheStreamValueFrom.ResponseBody = "choices.0.delta.content"
	}
	c.ReturnResponseTemplate = json.Get("returnResponseTemplate").String()
	if c.ReturnResponseTemplate == "" {
		c.ReturnResponseTemplate = `{"id":"from-cache","choices":[{"index":0,"message":{"role":"assistant","content":"%s"},"finish_reason":"stop"}],"model":"gpt-4o","object":"chat.completion","usage":{"prompt_tokens":0,"completion_tokens":0,"total_tokens":0}}`
	}
	c.ReturnStreamResponseTemplate = json.Get("returnStreamResponseTemplate").String()
	if c.ReturnStreamResponseTemplate == "" {
		c.ReturnStreamResponseTemplate = `data:{"id":"from-cache","choices":[{"index":0,"delta":{"role":"assistant","content":"%s"},"finish_reason":"stop"}],"model":"gpt-4o","object":"chat.completion","usage":{"prompt_tokens":0,"completion_tokens":0,"total_tokens":0}}` + "\n\ndata:[DONE]\n\n"
	}

	c.CacheKeyPrefix = json.Get("cacheKeyPrefix").String()
	if c.CacheKeyPrefix == "" {
		c.CacheKeyPrefix = DefaultCacheKeyPrefix
	}
	c.RedisClient = wrapper.NewRedisClusterClient(wrapper.FQDNCluster{
		FQDN: c.RedisInfo.ServiceName,
		Port: int64(c.RedisInfo.ServicePort),
	})
	err := c.RedisClient.Init(c.RedisInfo.Username, c.RedisInfo.Password, int64(c.RedisInfo.Timeout))
	if err != nil {
		log.Errorf("Failed to init redis client: %v", err)
		return err
	}

	log.Info("Init ai cache's components successfully.")
	return nil
}

func onHttpRequestHeaders(ctx wrapper.HttpContext, config PluginConfig, log wrapper.Log) types.Action {
	contentType, _ := proxywasm.GetHttpRequestHeader("content-type")
	// The request does not have a body.
	if contentType == "" {
		return types.ActionContinue
	}
	if !strings.Contains(contentType, "application/json") {
		log.Warnf("content is not json, can't process:%s", contentType)
		ctx.DontReadRequestBody()
		return types.ActionContinue
	}
	_ = proxywasm.RemoveHttpRequestHeader("Accept-Encoding")
	// The request has a body and requires delaying the header transmission until a cache miss occurs,
	// at which point the header should be sent.
	return types.HeaderStopIteration
}

func onHttpRequestBody(ctx wrapper.HttpContext, config PluginConfig, body []byte, log wrapper.Log) types.Action {
	bodyJson := gjson.ParseBytes(body)
	// TODO: It may be necessary to support stream mode determination for different LLM providers.
	stream := false
	if bodyJson.Get("stream").Bool() {
		stream = true
		ctx.SetContext(StreamContextKey, struct{}{})
	} else if ctx.GetContext(StreamContextKey) != nil {
		stream = true
	}
	key := TrimQuote(bodyJson.Get(config.CacheKeyFrom.RequestBody).Raw)
	if key == "" {
		log.Debug("parse key from request body failed")
		return types.ActionContinue
	}

	log.Infof("Receive key:%s.", key)

	isHasIgnorePreFix := strings.HasPrefix(key, config.DashVectorInfo.DashVectorIgnorePrefix)

	if isHasIgnorePreFix {
		key = strings.TrimPrefix(key, config.DashVectorInfo.DashVectorIgnorePrefix)
		QueueCache.addQueueQuestion(key, isHasIgnorePreFix)
	} else {
		QueueCache.addQueueQuestion(key, isHasIgnorePreFix)
		key = QueueCache.generate(&config.ProperNounSet)
	}

	EmbeddingUrl, EmbeddingRequestBody, EmbeddingHeader := GenerateTextEmbeddingsRequest(key, log)
	EmbeddingErr := config.DashScopeInfo.DashScopeClient.Post(
		EmbeddingUrl,
		EmbeddingHeader,
		EmbeddingRequestBody,
		func(statusCode int, responseHeaders http.Header, responseBody []byte) {
			if statusCode != 200 {
				log.Errorf("Failed to fetch embeddings, statusCode: %d, responseBody: %s", statusCode, string(responseBody))
				// result = nil
				ctx.SetContext(QueryEmbeddingKey, nil)
				ctx.SetContext(CacheKeyContextKey, nil)
				_ = proxywasm.ResumeHttpRequest()
			} else {
				log.Infof("Successfully fetched embeddings for key:%s.", key)
				DashScopeEmbeddingResponseBody, _ := TextEmbeddingsVectorResponse(responseBody, log)
				// 向量值
				EmbeddingVector := DashScopeEmbeddingResponseBody.Output.Embeddings[0].Embedding
				ctx.SetContext(QueryEmbeddingKey, EmbeddingVector)
				// Vector交互
				VectorUrl, VectorRequestBody, VectorHeader, _ := GenerateQueryNearestVectorRequest(config, EmbeddingVector, log)
				QueryNearestErr := config.DashVectorInfo.DashVectorClient.Post(
					VectorUrl,
					VectorHeader,
					VectorRequestBody,
					func(statusCode int, responseHeaders http.Header, responseBody []byte) {
						NearestResponseBody, _ := QueryVectorResponse(responseBody, log)
						if len(NearestResponseBody.Output) > 0 {
							NearestResponseBodyScore := NearestResponseBody.Output[0].Score
							NearestResponseBodyFields := NearestResponseBody.Output[0].Fields
							if (NearestResponseBodyScore <= config.DashVectorInfo.DashVectorNearestScoreThreshold && NearestResponseBodyScore >= config.DashVectorInfo.DashVectorNearestScoreMinThreshold) || NearestResponseBodyScore == 0 {
								log.Infof("Query similar question:%s, score:%f", NearestResponseBodyFields.OriginQuestion, NearestResponseBodyScore)
								if !stream {
									_ = proxywasm.SendHttpResponse(200, [][2]string{{"content-type", "application/json; charset=utf-8"}}, []byte(fmt.Sprintf(config.ReturnResponseTemplate, NearestResponseBodyFields.Content)), -1)
								} else {
									_ = proxywasm.SendHttpResponse(200, [][2]string{{"content-type", "text/event-stream; charset=utf-8"}}, []byte(fmt.Sprintf(config.ReturnStreamResponseTemplate, NearestResponseBodyFields.Content)), -1)
								}
								return
							} else {
								log.Infof("Query similar key, but the score of result is larger than the threshold, score:%f, maxThreshold:%f, minThreshold:%f, content:%s. ", NearestResponseBodyScore, config.DashVectorInfo.DashVectorNearestScoreThreshold, config.DashVectorInfo.DashVectorNearestScoreMinThreshold, NearestResponseBodyFields.OriginQuestion)
								ctx.SetContext(CacheKeyContextKey, key)
								_ = proxywasm.ResumeHttpRequest()
							}
						} else {
							log.Infof("Can not query nearest key:%s", key)
							ctx.SetContext(CacheKeyContextKey, key)
							_ = proxywasm.ResumeHttpRequest()
						}
					}, 100000)
				if QueryNearestErr != nil {
					log.Errorf("Query nearest vector error: %v", QueryNearestErr)
					_ = proxywasm.ResumeHttpRequest()
					return
				}
			}
		}, 10000)
	if EmbeddingErr != nil {
		log.Errorf("Embedding text error: %v", EmbeddingErr)
		_ = proxywasm.ResumeHttpRequest()
	}
	return types.ActionPause
}

func onHttpResponseHeaders(ctx wrapper.HttpContext, config PluginConfig, log wrapper.Log) types.Action {
	contentType, _ := proxywasm.GetHttpResponseHeader("content-type")
	if strings.Contains(contentType, "text/event-stream") {
		ctx.SetContext(StreamContextKey, struct{}{})
	}
	return types.ActionContinue
}

func onHttpResponseBody(ctx wrapper.HttpContext, config PluginConfig, chunk []byte, isLastChunk bool, log wrapper.Log) []byte {
	if ctx.GetContext(ToolCallsContextKey) != nil {
		// we should not cache tool call result
		return chunk
	}
	keyI := ctx.GetContext(CacheKeyContextKey)
	if keyI == nil {
		return chunk
	}
	if !isLastChunk {
		stream := ctx.GetContext(StreamContextKey)
		if stream == nil {
			tempContentI := ctx.GetContext(CacheContentContextKey)
			if tempContentI == nil {
				ctx.SetContext(CacheContentContextKey, chunk)
				return chunk
			}
			tempContent := tempContentI.([]byte)
			tempContent = append(tempContent, chunk...)
			ctx.SetContext(CacheContentContextKey, tempContent)
		} else {
			var partialMessage []byte
			partialMessageI := ctx.GetContext(PartialMessageContextKey)
			if partialMessageI != nil {
				partialMessage = append(partialMessageI.([]byte), chunk...)
			} else {
				partialMessage = chunk
			}
			messages := strings.Split(string(partialMessage), "\n\n")
			for i, msg := range messages {
				if i < len(messages)-1 {
					// process complete message
					processSSEMessage(ctx, config, msg, log)
				}
			}
			if !strings.HasSuffix(string(partialMessage), "\n\n") {
				ctx.SetContext(PartialMessageContextKey, []byte(messages[len(messages)-1]))
			} else {
				ctx.SetContext(PartialMessageContextKey, nil)
			}
		}
		return chunk
	}
	// last chunk
	key := keyI.(string)
	stream := ctx.GetContext(StreamContextKey)
	var value string
	if stream == nil {
		var body []byte
		tempContentI := ctx.GetContext(CacheContentContextKey)
		if tempContentI != nil {
			body = append(tempContentI.([]byte), chunk...)
		} else {
			body = chunk
		}
		bodyJson := gjson.ParseBytes(body)

		value = TrimQuote(bodyJson.Get(config.CacheValueFrom.ResponseBody).Raw)
		if value == "" {
			log.Warnf("parse value from response body failded, body:%s", body)
			return chunk
		}
	} else {
		if len(chunk) > 0 {
			var lastMessage []byte
			partialMessageI := ctx.GetContext(PartialMessageContextKey)
			if partialMessageI != nil {
				lastMessage = append(partialMessageI.([]byte), chunk...)
			} else {
				lastMessage = chunk
			}
			if !strings.HasSuffix(string(lastMessage), "\n\n") {
				log.Warnf("invalid lastMessage:%s", lastMessage)
				return chunk
			}
			// remove the last \n\n
			lastMessage = lastMessage[:len(lastMessage)-2]
			value = processSSEMessage(ctx, config, string(lastMessage), log)
		} else {
			tempContentI := ctx.GetContext(CacheContentContextKey)
			if tempContentI == nil {
				return chunk
			}
			value = tempContentI.(string)
		}
	}
	VectorBody := ctx.GetContext(QueryEmbeddingKey).([]float64)
	if VectorBody != nil {
		FieldsBody := Fields{
			OriginQuestion: key,
			Content:        value,
		}
		InsertVectorUrl, InsertVectorBody, InsertVectorHeader, _ := GenerateInsertDocumentsRequest(config, FieldsBody, VectorBody, log)
		log.Infof("insert doc key:%s, content:%s.", key, value)
		_ = config.DashVectorInfo.DashVectorClient.Post(
			InsertVectorUrl,
			InsertVectorHeader,
			InsertVectorBody,
			func(statusCode int, responseHeaders http.Header, responseBody []byte) {
				log.Infof("Insert vector statusCode:%d.", statusCode)
			},
			100000)
	}

	return chunk
}

func processSSEMessage(ctx wrapper.HttpContext, config PluginConfig, sseMessage string, log wrapper.Log) string {
	subMessages := strings.Split(sseMessage, "\n")
	var message string
	for _, msg := range subMessages {
		if strings.HasPrefix(msg, "data:") {
			message = msg
			break
		}
	}
	if len(message) < 6 {
		log.Errorf("invalid message:%s", message)
		return ""
	}
	// skip the prefix "data:"
	bodyJson := message[5:]
	if gjson.Get(bodyJson, config.CacheStreamValueFrom.ResponseBody).Exists() {
		tempContentI := ctx.GetContext(CacheContentContextKey)
		if tempContentI == nil {
			content := TrimQuote(gjson.Get(bodyJson, config.CacheStreamValueFrom.ResponseBody).Raw)
			ctx.SetContext(CacheContentContextKey, content)
			return content
		}
		contentAppend := TrimQuote(gjson.Get(bodyJson, config.CacheStreamValueFrom.ResponseBody).Raw)
		content := tempContentI.(string) + contentAppend
		ctx.SetContext(CacheContentContextKey, content)
		return content
	} else if gjson.Get(bodyJson, "choices.0.delta.content.tool_calls").Exists() {
		// TODO: compatible with other providers
		ctx.SetContext(ToolCallsContextKey, struct{}{})
		return ""
	}
	log.Debugf("unknown message:%s", bodyJson)
	return ""
}

func GenerateTextEmbeddingsRequest(texts string, log wrapper.Log) (string, []byte, [][2]string) {
	url := "/api/v1/services/embeddings/text-embedding"

	data := DashScopeEmbeddingRequest{
		Model: "zpoint",
		Input: texts,
		Parameters: Parameters{
			TextType: "query",
		},
	}

	requestBody, err := json.Marshal(data)
	if err != nil {
		log.Errorf("Marshal json error:%s, data:%s.", err, data)
		return "", nil, nil
	}

	headers := [][2]string{
		{"Content-Type", "application/json"},
	}
	return url, requestBody, headers
}

func GenerateInsertDocumentsRequest(c PluginConfig, fields Fields, vector []float64, log wrapper.Log) (string, []byte, [][2]string, error) {
	url := fmt.Sprintf("/v1/collections/%s/docs", c.DashVectorInfo.DashVectorCollection)

	DocumentsObject := Documents{
		Fields: fields,
		Vector: vector,
	}

	requestData := DashVectorInsertRequest{
		Documents: []Documents{DocumentsObject},
	}

	requestBody, err := json.Marshal(requestData)
	if err != nil {
		log.Errorf("Marshal json error:%s, data:%s.", err, requestData)
		return "", nil, nil, err
	}

	header := [][2]string{
		{"Content-Type", "application/json"},
		{"dashvector-auth-token", c.DashVectorInfo.DashVectorKey},
	}

	return url, requestBody, header, nil
}

func GenerateQueryNearestVectorRequest(c PluginConfig, vector []float64, log wrapper.Log) (string, []byte, [][2]string, error) {
	url := fmt.Sprintf("/v1/collections/%s/query", c.DashVectorInfo.DashVectorCollection)

	requestData := DashVectorSearchRequest{
		Vector:        vector,
		TopK:          1,
		IncludeVector: true,
	}

	requestBody, err := json.Marshal(requestData)
	if err != nil {
		log.Errorf("Marshal json error:%s, data:%s.", err, requestData)
		return "", nil, nil, err
	}

	header := [][2]string{
		{"Content-Type", "application/json"},
		{"dashvector-auth-token", c.DashVectorInfo.DashVectorKey},
	}

	return url, requestBody, header, nil
}

func GenerateQueryVectorByIdRequest(c PluginConfig, id uint64) (string, [][2]string) {
	url := fmt.Sprintf("/v1/collections/%s/docs?ids=%d", c.DashVectorInfo.DashVectorCollection, id)

	header := [][2]string{
		{"Content-Type", "application/json"},
		{"dashvector-auth-token", c.DashVectorInfo.DashVectorKey},
	}

	return url, header
}

func TextEmbeddingsVectorResponse(responseBody []byte, log wrapper.Log) (*DashScopeEmbeddingResponse, error) {
	var response DashScopeEmbeddingResponse
	err := json.Unmarshal(responseBody, &response)
	if err != nil {
		log.Errorf("[TextEmbeddingsVectorResponse] Unmarshal json error:%s, response:%s.", err, string(responseBody))
		return nil, err
	}
	return &response, nil
}

func QueryVectorResponse(responseBody []byte, log wrapper.Log) (*DashVectorSearchResponse, error) {
	var response DashVectorSearchResponse
	err := json.Unmarshal(responseBody, &response)
	if err != nil {
		log.Errorf("[QueryNearestVectorResponse]Unmarshal json error:%s, response:%s.", err, string(responseBody))
		return nil, err
	}
	return &response, nil
}

func zhToUnicode(raw []byte) ([]byte, error) {
	str, err := strconv.Unquote(strings.Replace(strconv.Quote(string(raw)), `\\u`, `\u`, -1))
	if err != nil {
		return nil, err
	}
	return []byte(str), nil
}

func TrimQuote(source string) string {
	TempKey := strings.Trim(source, `"`)
	Key, _ := zhToUnicode([]byte(TempKey))
	return string(Key)
}

func (q *Queue) addQueueQuestion(c string, clear bool) {
	if clear {
		q.clear()
	}
	if q.Size < q.MaxSize {
		q.ContentArray[q.Size] = c
		q.Size++
	} else {
		copiedArray := [1]string{}
		copy(copiedArray[:], q.ContentArray[0:1])
		copy(q.ContentArray[:], copiedArray[:])
		q.ContentArray[q.MaxSize-1] = c
	}
}

func (q *Queue) clear() {
	for i := 0; i < q.Size; i++ {
		q.ContentArray[i] = ""
	}
	q.Size = 0
}

func (q *Queue) generate(s *ProperNounStack) string {
	if q.Size <= 0 {
		return ""
	} else if q.Size == 1 {
		return q.ContentArray[0]
	} else {
		for _, ProperNounSetEle := range s.Coupe {
			HitCount := 0
			HitFirstNoun := ""
			HitSecondNoun := ""
			for _, ProperNoun := range ProperNounSetEle.Ele {
				if strings.Contains(q.ContentArray[0], ProperNoun) {
					HitCount++
					HitFirstNoun = ProperNoun
					continue
				}
				if strings.Contains(q.ContentArray[1], ProperNoun) {
					HitCount++
					HitSecondNoun = ProperNoun
					continue
				}
			}
			if HitCount >= 2 {
				return strings.ReplaceAll(q.ContentArray[0], HitFirstNoun, HitSecondNoun)
			}
		}

		Result := ""
		for i := 0; i < q.Size; i++ {
			Result = Result + q.ContentArray[i]
		}
		return Result
	}
}

func (s *ProperNounStack) print() string {
	Str, _ := json.Marshal(s)
	return string(Str)
}
